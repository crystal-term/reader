require "../spec_helper"

Spectator.describe "Term::Reader event subscription" do
  include TestHelpers
  
  let(input) { MockFileDescriptor.new(0) }
  let(output) { MockFileDescriptor.new(1) }
  let(reader) { Term::Reader.new(input: input, output: output) }
  
  describe "instance event handlers" do
    it "triggers handler for specific key" do
      event_capture = EventCapture.new
      reader.on_key(:enter, &event_capture.handler)
      
      input.inject_input("\r")
      reader.read_keypress
      
      expect(event_capture.has_event?("enter")).to be_true
      expect(event_capture.event_count("enter")).to eq(1)
    end
    
    it "triggers multiple handlers for same key" do
      calls = [] of Int32
      reader.on_key(:space) { |_, _| calls << 1; nil }
      reader.on_key(:space) { |_, _| calls << 2; nil }
      
      input.inject_input(" ")
      reader.read_keypress
      
      expect(calls).to eq([1, 2])
    end
    
    it "triggers catch-all handler for any key" do
      all_events = [] of String
      reader.on_key { |name, _| all_events << name; nil }
      
      input.inject_input("a")
      reader.read_keypress
      input.inject_input("\t")
      reader.read_keypress
      input.inject_input("\e[A")
      reader.read_keypress
      
      expect(all_events).to eq(["a", "tab", "up"])
    end
    
    it "provides correct event data" do
      captured_event = nil
      reader.on_key(:x) do |name, event|
        captured_event = event
        nil
      end
      
      input.inject_input("x")
      reader.read_keypress
      
      expect(captured_event).not_to be_nil
      event = captured_event.not_nil!
      expect(event.key.name).to eq("x")
      expect(event.value).to eq("x")
    end
    
    it "includes line content in event during read_line" do
      captured_event = nil
      reader.on_key(:o) do |name, event|
        captured_event = event
        nil
      end
      
      input.inject_input("hello\r")
      reader.read_line
      
      expect(captured_event).not_to be_nil
      event = captured_event.not_nil!
      expect(event.line).to eq("hello")
    end
  end
  
  describe "global event handlers (subscribe macro)" do
    # Create a test class that uses the subscribe macro
    class TestSubscriber
      getter events : Array({String, Term::Reader::KeyEvent}) = [] of {String, Term::Reader::KeyEvent}
      
      Term::Reader.subscribe(:ctrl_a, :ctrl_b)
      
      def keyctrl_a
        @events << {"ctrl_a", Term::Reader::KeyEvent.new(Term::Reader::Key.new("ctrl_a"), "ctrl_a")}
      end
      
      def keyctrl_b
        @events << {"ctrl_b", Term::Reader::KeyEvent.new(Term::Reader::Key.new("ctrl_b"), "ctrl_b")}
      end
    end
    
    it "triggers subscribed methods" do
      subscriber = TestSubscriber.new
      
      input.inject_input("\x01") # Ctrl+A
      reader.read_keypress
      
      expect(subscriber.events.size).to eq(1)
      expect(subscriber.events.first[0]).to eq("ctrl_a")
    end
    
    it "handles multiple subscriptions" do
      subscriber = TestSubscriber.new
      
      input.inject_input("\x01") # Ctrl+A
      reader.read_keypress
      input.inject_input("\x02") # Ctrl+B
      reader.read_keypress
      
      expect(subscriber.events.size).to eq(2)
      expect(subscriber.events.map(&.[0])).to eq(["ctrl_a", "ctrl_b"])
    end
  end
  
  describe "event handler combinations" do
    it "calls both instance and global handlers" do
      instance_called = false
      reader.on_key(:tab) { |_, _| instance_called = true; nil }
      
      # Global handler would be set via subscribe macro
      # For this test, we'll verify instance handlers work
      
      input.inject_input("\t")
      reader.read_keypress
      
      expect(instance_called).to be_true
    end
    
    it "calls specific and catch-all handlers" do
      specific_called = false
      catchall_called = false
      
      reader.on_key(:enter) { |_, _| specific_called = true; nil }
      reader.on_key { |_, _| catchall_called = true; nil }
      
      input.inject_input("\r")
      reader.read_keypress
      
      expect(specific_called).to be_true
      expect(catchall_called).to be_true
    end
  end
  
  describe "special key events" do
    it "triggers events for arrow keys" do
      arrows = [] of String
      reader.on_key(:up, :down, :left, :right) do |name, _|
        arrows << name
        nil
      end
      
      input.inject_input("\e[A") # up
      reader.read_keypress
      input.inject_input("\e[B") # down
      reader.read_keypress
      input.inject_input("\e[C") # right
      reader.read_keypress
      input.inject_input("\e[D") # left
      reader.read_keypress
      
      expect(arrows).to eq(["up", "down", "right", "left"])
    end
    
    it "triggers events for function keys" do
      function_keys = [] of String
      reader.on_key(:f1, :f2, :f3) do |name, _|
        function_keys << name
        nil
      end
      
      input.inject_input("\eOP")   # F1
      reader.read_keypress
      input.inject_input("\eOQ")   # F2
      reader.read_keypress
      input.inject_input("\eOR")   # F3
      reader.read_keypress
      
      expect(function_keys).to eq(["f1", "f2", "f3"])
    end
    
    it "triggers events for control keys" do
      control_keys = [] of String
      reader.on_key do |name, _|
        control_keys << name if name.starts_with?("ctrl_")
        nil
      end
      
      input.inject_input("\x01") # Ctrl+A
      reader.read_keypress
      input.inject_input("\x03") # Ctrl+C
      reader.read_keypress
      input.inject_input("\x04") # Ctrl+D
      reader.read_keypress
      
      expect(control_keys).to contain("ctrl_a")
      expect(control_keys).to contain("ctrl_c")
      expect(control_keys).to contain("ctrl_d")
    end
  end
  
  describe "event handler array syntax" do
    it "accepts array of keys" do
      keys_pressed = [] of String
      reader.on_key([:a, :b, :c]) do |name, _|
        keys_pressed << name
        nil
      end
      
      input.inject_input("abc")
      reader.read_keypress
      reader.read_keypress
      reader.read_keypress
      
      expect(keys_pressed).to eq(["a", "b", "c"])
    end
  end
end